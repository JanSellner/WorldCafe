<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Group Allocation</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap-reboot.min.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="{{ url_for('static', filename='highcharts.bundle.min.js') }}"></script>
    <script src="{{ url_for('static', filename='popper.min.js') }}"></script>
    <script src="{{ url_for('static', filename='tippy.min.js') }}"></script>
    <script src="{{ url_for('static', filename='d3.bundle.min.js') }}"></script>
    <script>
        window.MathJax = {
            tex: {
                tags: 'ams'
            }
        };
    </script>
    <script id="MathJax-script" async src="{{ url_for('static', filename='mathjax/tex-chtml.js') }}"></script>
    <script src="{{ url_for('static', filename='socket.io.slim.js') }}"></script>
    <script>
        var socket = io();
        socket.on('connect', function() {
            let sidField = document.getElementById('sid');
            if (sidField.value) {
                // Inform the server that the sid changed
                socket.emit('session_change', sidField.value);

                // Avoid form resubmission on page refresh (https://stackoverflow.com/a/45656609)
                if (window.history.replaceState) {
                    window.history.replaceState(null, null, window.location.href);
                }
            }

            sidField.value = socket.id;
        });
        socket.on('update_progress', function (data) {
            const progress = document.getElementById('progress');
            progress.setAttribute('value', data['progress']);
            progress.setAttribute('title', 
                                  
                                  
                                  format(".1f")(data['progress'] * 100) + ' %');

            if (data['remaining_time'] !== null) {
                const minutes = Math.floor(data['remaining_time'] / 60);
                const seconds = data['remaining_time'] % 60;
                document.getElementById('remaining_time').innerHTML = `Remaining time: ${minutes} m and ${seconds} s`;
            }
        });
    </script>
</head>
<body>
    <a id="github_logo" href="https://github.com/Milania1/GroupAllocation" target="_blank" rel="noopener noreferrer" title="Fork me on GitHub"></a>
    <h1>Group Allocation</h1>
    <p>Have you ever been in the situation where you had to calculate an allocation of users to groups across several days with changing groups per day? Then, you are on the right page. If you already know the problem, go directly to the <a href="#sec:input">input section</a> and specify your situation. If not, keep on reading...</p>

    <p>To understand the problem, suppose we have 30 users and three events A, B and C happening per day with a total time budget of three days. We split the users into three groups à 10 people (group I, II and III) and assign each group to an event. So, for the first day, we may end up with the allocation A-I, B-II and C-III. On the second day, we assign the groups to different events, e.g. A-II, B-III, C-I (this leaves A-III, B-I, and C-II for the last day). In the end, each user participated in each event exactly once.</p>

    <p>The problem with this approach is that only the users from the same group see each other. However, it might be desired that each user meets as many other users as possible during the three days so that different discussions can be facilitated. Here, you can run an algorithm which tries to find a better allocation so that the number of meetings between the users is as high as possible. Simply specify the number of groups/days as well as a list of users and run the algorithm. The results are then directly shown on this page.</p>

    <h2 id="sec:input">Data Input</h2>
    <form action="/#sec:result" method="POST" enctype="multipart/form-data">
        {{ form.sid() }}
        {% for error in form.sid.errors %}
            <span class="error">{{ error }}</span>
        {% endfor %}

        {{ form.n_groups.label }}: {{ form.n_groups() }}
        {% for error in form.n_groups.errors %}
            <span class="error">{{ error }}</span>
        {% endfor %}
        <br />

        <div class="tabs">
            {{ (form.selection_type|list)[0] }}
            {{ (form.selection_type|list)[0].label }}
            <div class="tab">
                <p>Please enter the names of the users (one per line):</p>
                {{ form.users(title=form.users.description) }}
                {% for error in form.users.errors %}
                    <span class="error">{{ error }}</span>
                {% endfor %}
                <br />
            </div>

            {{ (form.selection_type|list)[1] }}
            {{ (form.selection_type|list)[1].label }}
            <div class="tab">
                <p>Please upload a valid CSV file according to the following specification (<a href="{{ url_for('static', filename='example_data.csv') }}">example file</a>):</p>
                <ul>
                    <li>The file is encoded as <a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener noreferrer" title="UTF-8 - Wikipedia">UTF-8</a>.</li>
                    <li>Comma (<code>,</code>) is used as separator.</li>
                    <li>First row must be a header row.</li>
                    <li>If you want the names of the users to appear in the output, include either two columns <code>First Name</code> and <code>Family Name</code> or just one column <code>Name</code>.</li>
                    <li>Optionally, one column can be <code>Foreigner</code> with either <code>true</code> or <code>false</code> values. This is interpreted by the system and it tries to find a solution which equally distributes foreigners and non-foreigners over the days.</li>
                </ul>
                {{ form.file.label(title=form.file.description) }}: {{ form.file() }}
                {% for error in form.file.errors %}
                    <span class="error">{{ error }}</span>
                {% endfor %}
                <br />
                <script>
                    // Goal: Keep the uploaded file in the form element even after a page refresh (e.g. due to form submission)
                    // This is done by manually storing the file in the session storage and loading it after the page refresh
                    // The session storage is unique for each tab and gets automatically deleted when the tab is closed (https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
                    document.getElementById('file').addEventListener('input', function (event) {
                        const file = event.target.files[0];

                        // Relevant information about the file required for reconstructions
                        let sessionFile = {
                           lastModified: file.lastModified,
                           name: file.name,
                           type: file.type
                        };

                        let fileReader = new FileReader();
                        fileReader.onload = function (event) {
                            sessionFile.content = event.target.result;

                            // We can only store strings in the session storage
                            sessionStorage.setItem('file', JSON.stringify(sessionFile));
                        };
                        fileReader.readAsText(file);
                    });

                    let sessionFile = sessionStorage.getItem('file');
                    if (sessionFile !== null) {
                        sessionFile = JSON.parse(sessionFile);

                        // Construct a new file object based on the stored information
                        const newFile = new File([sessionFile.content], sessionFile.name, {
                            type: sessionFile.type,
                            lastModified: sessionFile.lastModified
                        });

                        // Create a new FileList object (https://stackoverflow.com/a/56447852)
                        let fileList = new DataTransfer();
                        fileList.items.add(newFile);

                        // Overwrite the input element (this has a visible effect for the user)
                        document.getElementById('file').files = fileList.files;
                    }
                </script>
            </div>
        </div>

        <details id="advanced">
            <script>
                // Store the state of the advanced details section in the current session so that there is no need for the user to re-open the section even after a page refresh
                document.getElementById('advanced').addEventListener('toggle', function (event) {
                    sessionStorage.setItem('advanced', JSON.stringify(event.target.open));
                });

                const sessionAdvanced = sessionStorage.getItem('advanced');
                if (sessionAdvanced !== null) {
                    document.getElementById('advanced').open = JSON.parse(sessionAdvanced);
                }
            </script>
            <summary>Advanced: <span class="normal">specify the \(\alpha\) weights manually</span></summary>

            <p>It is possible to exercise some control over the execution of the algorithm by explicitly specifying the \(\alpha\) weights for the error function. This allows shifting the focus on different aspects of the optimization. For example, it is sometimes possible to increase the average number of meetings of the users while approving less consistent group sizes. The focus can be adjusted by moving the red circle inside the triangle below. With increasing weight value, higher importance is given to the corresponding part of the error function. This means that this part is preferred in the optimization process yielding lower error values. For example, when \(\alpha_s\) increases, usually \(E_s\) decreases resulting in better group sizes.</p>

            <p>Note: a change of the weights may not directly result in a different output since the solution landscape tends to behave discretely. Many weight settings end up with the same allocation (or, more precisely, an equivalent allocation which has the same error characteristics). However, there is usually a point where it tips over and you get a different result.</p>

            <svg id="parameter_selection" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 201.44 171.06"><defs><style>.cls-1{fill:#fff;stroke-width:2px;}.cls-1,.cls-5{stroke:#000;stroke-miterlimit:10;}.cls-2{font-size:12px;}.cls-2,.cls-3{font-size:10px;}.cls-3,.cls-6{font-style:italic;}.cls-4{font-style:normal;}.cls-5{fill:#c1272d;stroke-width:0.5px;}.cls-6{font-size:8px;}</style></defs><polygon id="triangle" class="cls-1" points="98.37 26.63 31.19 142.99 165.56 142.99 98.37 26.63"/><text id="meetings" class="cls-2" transform="translate(0 154.7)">Meetings<tspan class="cls-3"><tspan x="4.79" y="12">α</tspan><tspan class="cls-4" x="11.05" y="12" xml:space="preserve">  = 0.33</tspan></tspan></text><text id="size" class="cls-2" transform="translate(88.63 10.2)">Size<tspan class="cls-3"><tspan x="-9.34" y="12">α</tspan><tspan class="cls-4" x="-3.08" y="12" xml:space="preserve">  = 0.33</tspan></tspan></text><text id="foreigners" class="cls-2" transform="translate(145.8 154.7)">Foreigners<tspan class="cls-3"><tspan x="7.99" y="12">α</tspan><tspan class="cls-4" x="14.25" y="12" xml:space="preserve">  = 0.33</tspan></tspan></text><circle id="pointer" class="cls-5" cx="99.37" cy="98.2" r="4"/><text class="cls-6" transform="translate(85.54 23.45)">s</text><text class="cls-6" transform="translate(159.94 168.95) scale(1 0.83)">f</text><text class="cls-6" transform="translate(10.21 168.95) scale(0.85 1)">m</text></svg>

            {{ form.alpha1(class='alphas') }}
            {{ form.alpha2(class='alphas') }}
            {{ form.alpha3(class='alphas') }}
            {% for error in form.alpha1.errors %}
                <span class="error">{{ error }}</span>
            {% endfor %}
            {% for error in form.alpha2.errors %}
                <span class="error">{{ error }}</span>
            {% endfor %}
            {% for error in form.alpha3.errors %}
                <span class="error">{{ error }}</span>
            {% endfor %}
            <script>
                // http://blog.acipo.com/matrix-inversion-in-javascript/
                // Returns the inverse of matrix `M`.
                function matrixInvert(M) {
                    // I use Guassian Elimination to calculate the inverse:
                    // (1) 'augment' the matrix (left) by the identity (on the right)
                    // (2) Turn the matrix on the left into the identity by elemetry row ops
                    // (3) The matrix on the right is the inverse (was the identity matrix)
                    // There are 3 elemtary row ops: (I combine b and c in my code)
                    // (a) Swap 2 rows
                    // (b) Multiply a row by a scalar
                    // (c) Add 2 rows

                    //if the matrix isn't square: exit (error)
                    if (M.length !== M[0].length) {
                        return;
                    }

                    //create the identity matrix (I), and a copy (C) of the original
                    var i = 0, ii = 0, j = 0, dim = M.length, e = 0, t = 0;
                    var I = [], C = [];
                    for (i = 0; i < dim; i += 1) {
                        // Create the row
                        I[I.length] = [];
                        C[C.length] = [];
                        for (j = 0; j < dim; j += 1) {

                            //if we're on the diagonal, put a 1 (for identity)
                            if (i === j) {
                                I[i][j] = 1;
                            } else {
                                I[i][j] = 0;
                            }

                            // Also, make the copy of the original
                            C[i][j] = M[i][j];
                        }
                    }

                    // Perform elementary row operations
                    for (i = 0; i < dim; i += 1) {
                        // get the element e on the diagonal
                        e = C[i][i];

                        // if we have a 0 on the diagonal (we'll need to swap with a lower row)
                        if (e === 0) {
                            //look through every row below the i'th row
                            for (ii = i + 1; ii < dim; ii += 1) {
                                //if the ii'th row has a non-0 in the i'th col
                                if (C[ii][i] !== 0) {
                                    //it would make the diagonal have a non-0 so swap it
                                    for (j = 0; j < dim; j++) {
                                        e = C[i][j];       //temp store i'th row
                                        C[i][j] = C[ii][j];//replace i'th row by ii'th
                                        C[ii][j] = e;      //repace ii'th by temp
                                        e = I[i][j];       //temp store i'th row
                                        I[i][j] = I[ii][j];//replace i'th row by ii'th
                                        I[ii][j] = e;      //repace ii'th by temp
                                    }
                                    //don't bother checking other rows since we've swapped
                                    break;
                                }
                            }
                            //get the new diagonal
                            e = C[i][i];
                            //if it's still 0, not invertable (error)
                            if (e === 0) {
                                return
                            }
                        }

                        // Scale this row down by e (so we have a 1 on the diagonal)
                        for (j = 0; j < dim; j++) {
                            C[i][j] = C[i][j] / e; //apply to original matrix
                            I[i][j] = I[i][j] / e; //apply to identity
                        }

                        // Subtract this row (scaled appropriately for each row) from ALL of
                        // the other rows so that there will be 0's in this column in the
                        // rows above and below this one
                        for (ii = 0; ii < dim; ii++) {
                            // Only apply to other rows (we want a 1 on the diagonal)
                            if (ii === i) {
                                continue;
                            }

                            // We want to change this element to 0
                            e = C[ii][i];

                            // Subtract (the row above(or below) scaled by e) from (the
                            // current row) but start at the i'th column and assume all the
                            // stuff left of diagonal is 0 (which it should be if we made this
                            // algorithm correctly)
                            for (j = 0; j < dim; j++) {
                                C[ii][j] -= e * C[i][j]; //apply to original matrix
                                I[ii][j] -= e * I[i][j]; //apply to identity
                            }
                        }
                    }

                    //we've done all operations, C should be the identity
                    //matrix I should be the inverse:
                    return I;
                }

                function distance(p1, p2) {
                    const x = Math.pow(p1.x - p2.x, 2);
                    const y = Math.pow(p1.y - p2.y, 2);

                    return Math.sqrt(x + y);
                }

                function norm(p) {
                    return Math.sqrt(p.x*p.x + p.y*p.y);
                }

                function normalize(p) {
                    const pNorm = norm(p);
                    return {
                        x: p.x / pNorm,
                        y: p.y / pNorm
                    };
                }

                function closestPoints(current) {
                    let pointsCopy = points.slice();
                    pointsCopy.sort((p1, p2) => distance(p1, current) - distance(p2, current));

                    return [pointsCopy[0], pointsCopy[1]]
                }

                function clamp(value, min, max) {
                    return Math.min(Math.max(value, min), max);
                }

                function setAlphasText(alpha1, alpha2, alpha3) {
                    d3.select('#size > tspan > tspan:last-child').text('  = ' + d3.format('.2f')(alpha1));
                    d3.select('#meetings > tspan > tspan:last-child').text('  = ' + d3.format('.2f')(alpha2));
                    d3.select('#foreigners > tspan > tspan:last-child').text('  = ' + d3.format('.2f')(alpha3));
                }

                const svg = document.getElementById('parameter_selection');
                const pointer = document.getElementById('pointer');
                const triangle = document.getElementById('triangle');

                // Points of the triangle
                const pointsList = document.querySelector('#triangle').points;
                let points = new Array(pointsList.length - 1);  // The last point is identical to the first
                for (let i = 0; i < points.length; ++i) {
                    points[i] = pointsList[i];
                }

                // Set the alphas in the image to the current values from the forms
                const alpha1 = document.getElementById('alpha1').value;
                const alpha2 = document.getElementById('alpha2').value;
                const alpha3 = document.getElementById('alpha3').value;
                setAlphasText(alpha1, alpha2, alpha3);

                // Update also the position of the pointer accordingly
                const currentPos = {
                    x: alpha1 * points[0].x + alpha2 * points[1].x + alpha3 * points[2].x,
                    y: alpha1 * points[0].y + alpha2 * points[1].y + alpha3 * points[2].y
                };
                d3.select(pointer).attr("cx", currentPos.x)
                                  .attr("cy", currentPos.y );

                // Prepare matrix for barycentric coordinates
                const T = [[points[0].x - points[2].x, points[1].x - points[2].x],
                           [points[0].y - points[2].y, points[1].y - points[2].y]];
                const Tinv = matrixInvert(T);

                function dragStart() {
                    d3.select(pointer).style("stroke-width", "1.5px");
                }

                function drag() {
                    let event = d3.event;
                    if (event.hasOwnProperty('sourceEvent')) {
                        event = event.sourceEvent;
                    }
                    const tags = document.elementsFromPoint(event.clientX, event.clientY);    // Viewport coordinates
                    const mouse = d3.mouse(this);
                    const current = {
                        x: mouse[0],  // In SVG coordinates
                        y: mouse[1]
                    };

                    // First check whether the mouse is also over the triangle
                    let newPoint = null;
                    for (let tag of tags) {
                        if (tag.tagName === 'polygon') {
                            newPoint = current;
                            break;
                        }
                    }

                    if (newPoint === null) {
                        // Mouse is outside of the triangle --> move pointer to the projection on the closest triangle side
                        // p1 + <e, p1Current> * e
                        const [p1, p2] = closestPoints(current);
                        const p1CurrentVec = {
                            x: current.x - p1.x,
                            y: current.y - p1.y
                        };
                        let p1p2Vec = {
                            x: p2.x - p1.x,
                            y: p2.y - p1.y
                        };

                        p1p2Vec = normalize(p1p2Vec);
                        const dot = p1p2Vec.x * p1CurrentVec.x + p1p2Vec.y * p1CurrentVec.y;

                        if (dot < 0) {
                            // Projection is not on the triangle side --> move to the corner
                            newPoint = p1;
                        }
                        else {
                            newPoint = {
                                x: p1.x + p1p2Vec.x * dot,
                                y: p1.y + p1p2Vec.y * dot
                            };
                        }
                    }

                    // Calculate barycentric coordinates (weighted sum of the triangle points)
                    const diffX = newPoint.x - points[2].x;
                    const diffY = newPoint.y - points[2].y;
                    let alpha1 = clamp(Tinv[0][0] * diffX + Tinv[0][1] * diffY, 0, 1);
                    let alpha2 = clamp(Tinv[1][0] * diffX + Tinv[1][1] * diffY, 0, 1);
                    let alpha3 = clamp(1 - alpha1 - alpha2, 0, 1);

                    // It is possible that the values don't sum exactly up to 1 (maybe due to numeric instabilities)
                    // As a countermeasure, the values are rescaled
                    const sum = alpha1 + alpha2 + alpha3;
                    alpha1 /= sum;
                    alpha2 /= sum;
                    alpha3 /= sum;

                    setAlphasText(alpha1, alpha2, alpha3);

                    // Update the (invisible) forms
                    document.getElementById('alpha1').value = alpha1;
                    document.getElementById('alpha2').value = alpha2;
                    document.getElementById('alpha3').value = alpha3;

                    // Move pointer
                    d3.select(pointer).attr("cx", newPoint.x)
                                      .attr("cy", newPoint.y);
                }

                function dragEnd() {
                    d3.select(pointer).style("stroke-width", "0.5px");
                }

                d3.select(svg).on('click', drag);
                d3.select(pointer).call(d3.drag()
                    .on("start", dragStart)
                    .on("drag", drag)
                    .on("end", dragEnd)
                );
            </script>
        </details>

        {{ form.submit() }}
        <script>
            document.querySelector('form').addEventListener('submit', function () {
                // Remove any error which may exists
                const serverError = document.getElementById('server_error');
                if (serverError !== null) {
                    serverError.parentNode.removeChild(serverError);
                }
            });
        </script>
        <label for="progress">Progress:</label>
        <progress id="progress" value="{{ form.progress_bar }}" title="{{ '0 %' if form.progress_bar == 0 else '100 %'}}"></progress>
        <span id="remaining_time"></span>
    </form>

    {% if error %}
    <p class="error" id="server_error">{{ error }}</p>
    {% endif %}

    {% if stats is defined %}
    <h2 id="sec:result">Result</h2>
    {% macro table_day(data) %}
    <table>
        <thead>
            <tr>
                <th>Group</th>
                {% for column in table.columns %}
                <th>{{ column }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
            {% for group_data in data %}
                {% for row in group_data.members %}
                <tr>
                    {% if loop.index0 == 0 %}
                    <td rowspan="{{ group_data.members|length }}" data-tippy-content="<span class='tooltip_heading'>{{ group_data.name }}</span>{% if 'foreigners' in group_data %}<br />{{ group_data['non-foreigners'] }} non-foreigners<br>{{ group_data['foreigners'] }} foreigners{% endif %}">{{ group_data.name }}<br />({{ group_data.members|length }} members)</td>
                    {% endif %}
                    {% for value in row %}
                    <td>{{ value }}</td>
                    {% endfor %}
                </tr>
                {% endfor %}

                {% if loop.index != data|length %}
                <tr class="separator"></tr>
                {% endif %}
            {% endfor %}
        </tbody>
    </table>
    {% endmacro %}

    <ul>
        {% for warning in messages.warnings %}
            <li class="warning">{{ warning }}</li>
        {% endfor %}
        {% for note in messages.notes %}
            <li>{{ note }}</li>
        {% endfor %}
        <li>
            {{ stats.members.names|length }} users in total.
            {% if 'n_foreigners' in stats %}
            <ul>
                <li>{{stats['n_non-foreigners']}} non-foreigners</li>
                <li>{{stats['n_foreigners']}} foreigners</li>
            </ul>
            {% endif %}
        </li>
        <li>Error: \(E(A_*) = \alpha_s \cdot {{ stats.error_size }} + \alpha_m \cdot {{ stats.error_meetings }} {{ '+ \\alpha_f \\cdot ' + stats.error_foreigners|string if 'error_foreigners' in stats }} = {{stats.error}}\) (the lower the better the allocation). Please note that an error of 0 is not possible in general.</li>
        <li>Download the results as <a download="GroupAllocation.csv" href="data:text/csv;base64,{{ csv_data }}">CSV file</a>.</li>
    </ul>

    <div id="stats">
        <div id="member_stats"></div>
        <div id="group_stats"></div>
    </div>
    <script>
        var memberStats = {{ stats.members|safe }};
        var colors = {};
        for (let i = 0; i < memberStats.names.length; ++i) {
            {% if 'n_foreigners' in stats %}
            if (memberStats.foreigners[i] === 0) {
                colors[memberStats.names[i]] = Highcharts.defaultOptions.colors[0];
            }
            else {
                colors[memberStats.names[i]] = Highcharts.defaultOptions.colors[1];
            }
            {% else %}
            colors[memberStats.names[i]] = '#666666';
            {% endif %}
        }

        Highcharts.chart('member_stats', {
            chart: {
                type: 'bar'
            },
            title: {
                text: `How many users does everyone meet? (μ = ${memberStats['meets_others_mean']})`
            },
            xAxis: {
                categories: memberStats['names'],
                labels: {
                    formatter () {
                        return `<span style="color: ${colors[this.value]}; max-width: 10px">${this.value}</span>`
                    },
                    style: {
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap',
                        width: 100,
                    }
                },
            },
            yAxis: {
                tickInterval: 2,
                min: 0,
                allowDecimals: false,
                title: {
                    text: 'Number of users'
                }
            },
            legend: {
                reversed: true
            },
            tooltip: {
                shared: true
            },
            plotOptions: {
                series: {
                    stacking: 'normal',
                    states: {
                        hover: {
                            brightness: 0.2
                        }
                    }
                }
            },
            series: [
                {% if 'n_foreigners' in stats %}
                {
                    name: 'Non-Foreigners',
                    data: memberStats['meets_non-foreigners']
                },
                {
                    name: 'Foreigners',
                    data: memberStats['meets_foreigners']
                }
                {% else %}
                {
                    showInLegend: false,
                    data: memberStats['meets_others']
                }
                {% endif %}
            ]
        });

        var groupStats = {{ stats.groups|safe }};

        var days = new Array(groupStats.sizes.length);
        var series = [];
        for (let i = 0; i < days.length; ++i) {
            days[i] = 'Day ' + (i + 1);
            series.push({
                name: 'Group ' + (i + 1),
                data: groupStats.sizes[i]
            });
        }

        Highcharts.chart('group_stats', {
            chart: {
                type: 'column'
            },
            title: {
                text: `Group Sizes (μ = ${groupStats['sizes_mean']})`
            },
            xAxis: {
                categories: days,
                crosshair: true
            },
            yAxis: {
                min: 0,
                allowDecimals: false,
                title: {
                    text: 'Number of users'
                }
            },
            tooltip: {
                shared: true
            },
            plotOptions: {
                column: {
                    pointPadding: 0.2,
                    borderWidth: 0
                }
            },
            series: series
        });
    </script>

    {% for data_day in table.days %}
        <details {{ 'open' if loop.index0 == 0 }}>
            <summary>Day {{ loop.index }}</summary>
            {{ table_day(data_day) }}
        </details>
    {% endfor %}

    <script>
        tippy('td[rowspan]', {
            interactive: true
        });
    </script>
    {% endif %}

    <h2>How Does It Work?</h2>
    <p>It starts with the observation that there is a choice when assigning users to groups. That is, we have some control over the order of group assignments, i.e. at which day a user participates in a certain group. Since we must assign each user to every group exactly once, we have the following combinations per user (for a three-day course):</p>

    <object type="image/svg+xml" data="{{ url_for('static', filename='CombinationsTree.svg') }}"></object>

    <p>In the beginning, we can assign the user to any of the three groups. After the first assignment, though, our choices are limited to only two groups on the second day. Finally, there is only one group left to be assigned for the user on the last day. In total, we have \(n_{\text{days}}! = 3! = 6\) choices for a single user. The same procedure repeats for every user and a choice for one user has a possible impact to the choices of all other users so that we have \(\left(n_{\text{days}}!\right)^{n_{\text{users}}}\) possible combinations to assign all the users to the groups over the days.</p>

    <p>Every combination has its own characteristic regarding e.g. the number of meetings between the users. We just need to find the combination which meets our desires. It is best to be preciser about which combinations are good and which not so that we can compare them. Let \(A\) denote a matrix with one possible allocation from users to groups over days (one combination). For example, the following matrix defines an allocation for 6 users (columns) and three groups/days (rows)</p>

    \begin{equation}
    \label{eq:ExampleAllocation}
        A =
        \begin{pmatrix}
            3 & 3 & 1 & 3 & 3 & 2 \\
            2 & 1 & 3 & 1 & 2 & 1 \\
            1 & 2 & 2 & 2 & 1 & 3
        \end{pmatrix}.
    \end{equation}

    <p>This matrix serves also as a running example in the subsequent sections. To evaluate the allocation, we define the error function</p>

    \begin{equation}
    \label{eq:TotalError}
        E(A) = \alpha_s \cdot E_s(A) + \alpha_m \cdot E_m(A) + \alpha_f \cdot E_f(A)
    \end{equation}

    <p>which takes three components into account: \(E_s\) for the group sizes, \(E_m\) for the number of meetings and \(E_f\) for a balance between foreigners and non-foreigners.</p>

    <p>The weights \(\alpha_s, \alpha_m, \alpha_f \in [0;1]\) can be used to control the focus of the algorithm. For example, when it is desired to have more meetings at the cost of more imbalanced group sizes, \(\alpha_m > \alpha_s\) should be set. In total, the weights should sum up to 1, i.e.</p>

    \begin{equation*}
        \alpha_s + \alpha_m + \alpha_f = 1.
    \end{equation*}

    <p>In the following, the components of the error function are described in more detail.</p>

    <h3>Group Sizes \(E_s\)</h3>
    <p>Many allocations end up with very degenerated group sizes, e.g. when all users are assigned to the first group and the other groups remain empty. These allocations are not really applicable. It is often more desired to have the group sizes balanced for each group and all days. Therefore, we calculate a matrix \(C_s(A)\) with the group sizes per group and day and calculate the error as</p>

    \begin{equation*}
        E_s(A) = \operatorname{mean}\left(\left|\frac{C_s(A) - s^*}{s^*}\right|\right) + \operatorname{std}\left(\frac{C_s(A)}{s^*}\right).
    \end{equation*}

    <p>The first summand measures how close the group sizes are to the optimal group size \(s^*\)</p>

    \begin{equation*}
        s^* = \frac{n_{\text{users}}}{n_{\text{groups}}} = \frac{\textit{columns of A}}{\textit{rows of A}}
    \end{equation*}

    <p>which corresponds to (roughly) equally distributed groups. The second summand ensures that all group sizes are good (and not e.g. just one) by penalizing high variances of the counts.</p>

    <p>Both parts are normalized by \(s^*\) to make this error function more comparable to the other error components of Equation \eqref{eq:TotalError}. Ideally, each function would be in the range \([0;1]\) so that we can easily interpret and manipulate them. However, this is not always true for \(E_s(A)\) (but it is for the others) since values \(>1\) may occur for highly imbalanced groups. This can also be an advantage, though, as it is in general desired to have equal group sizes and it is good to have a high penalty when this is not the case.</p>

    <p>For our example allocation (Equation \eqref{eq:ExampleAllocation}), we have the following group sizes</p>

    \begin{equation*}
        C_s(A) =
        \begin{pmatrix}
            1 & 1 & 4 \\
            3 & 2 & 1 \\
            2 & 3 & 1
        \end{pmatrix}
    \end{equation*}

    <p>with each row denoting a day and each column a group. For example, we have \((C_s(A))_{0,2} = 4\) because four members are in the third group on the first day (first row in \(A\)). Since the optimal group size is \(s^* = 6/3 = 2\), we get the error</p>

    \begin{equation*}
        E_s(A) \approx 0.44 + 0.56 = 1
    \end{equation*}

    <p>which is quite high but there is also room for improvement in the allocation.</p>

    <h3>Meetings \(E_m\)</h3>
    <p>The whole point of the algorithm is to find an allocation where more users meet than in the trivial allocation where the group members stay fixed. This aspect is covered by the error term \(E_m(A)\) which counts how many other users (including herself/himself) a participant meets. Let \(C_m(A)\) denote a vector which holds this information. Then, the error for the meetings is calculated as (\(n\) denotes the number of users)</p>

    \begin{equation*}
        E_m(A) = 1 - \operatorname{mean}\left( \frac{C_m(A)}{n} \right) + \operatorname{std}\left( \frac{C_m(A)}{n} \right).
    \end{equation*}

    <p>The summands have a similar meaning as before. Ideally, each participant meets all other users (average part) and the number of meetings should be roughly equal among the users (standard deviation part). The latter ensures that, for example, there is not only one user who meets nearly all and another who stays with the same people all the time. The counts \(C_m(A)\) are used to normalize the values and keep them roughly in the range \([0;1]\).</p>

    <p>For the example of Equation \eqref{eq:ExampleAllocation}, we get the following meeting vector</p>

    \begin{equation*}
        C_m(A) =
        \begin{pmatrix}
            4 & 6 & 3 & 6 & 4 & 3
        \end{pmatrix}
    \end{equation*}

    <p>with the meetings for each user. To find these values, we need to search \(A\) for users who are in the same group as the current user. For example, the last user can only talk to the second and fourth user since they are in the same group on the second day (they are all in group 1). On the other days, the user is alone (there are no other users in the second or third group on the first and last day, respectively). This leads to the error</p>

    \begin{equation*}
        E_m(A) \approx 0.28 + 0.23 = 0.51.
    \end{equation*}

    <h3>Foreigners \(E_f\)</h3>
    <p>In case you submitted a <code>Foreigner</code> attribute to the algorithm, there is another aspect to consider. This is relevant when there is a mixed group of non-foreigners and foreigners and the goal is that each group should consist of both. This is taken care of by the error term \(E_f(A)\). For each group and day, it calculates the vector \(\boldsymbol{p} = (p_f, p_{\bar{f}})\) with the probabilities \(p_f\) and \(p_{\bar{f}}\) for the ratio of foreigners and non-foreigners, respectively. Then, the entropy</p>

    \begin{equation}
    \label{eq:EntropyVector}
        s(\boldsymbol{p}) = p_f \cdot \log_2\left( \frac{1}{p_f} \right) + p_{\bar{f}} \cdot \log_2\left( \frac{1}{p_{\bar{f}}} \right)
    \end{equation}

    <p>measures how well these two types of users are represented in each group. Since \(\boldsymbol{p}\) is a valid probability vector with its components summing up to 1, it is sufficient when we know one component as we can infer the second one, e.g. \((p_f, p_{\bar{f}}) = (p_f, 1-p_f)\). In this case, Equation \eqref{eq:EntropyVector} simplifies to</p>

    \begin{equation}
    \label{eq:Entropy}
        s(p_f) = p_f \cdot \log_2\left( \frac{1}{p_f} \right) + (1-p_f) \cdot \log_2\left( \frac{1}{1-p_f} \right)
    \end{equation}

    <p>and this function depends only on the fraction of foreigners \(p_f\) in the group. What is more, it is now easily possible to plot Equation \eqref{eq:Entropy} as a function of \(p_f\) and see which entropy values we get for a certain fraction of foreigners in our group:</p>

    <div id="entropy_plot"></div>
    <script>
        // Generate the data for the entropy function
        let data = [{
            x: 0,
            y: 0
        }];

        const step = 0.01;
        for (let p = step; p < 1; p += step) {
            data.push({
                x: p,
                y: -p * Math.log2(p) - (1-p) * Math.log2(1-p)
            });
        }

        data.push({
            x: 1,
            y: 0
        });

        Highcharts.chart('entropy_plot', {
            chart: {
                type: 'spline',
                zoomType: 'xy'
            },
            title: {
                text: 'Entropy impurity measure'
            },
            xAxis: {
                gridLineWidth: 1,
                title: {
                    useHTML: true,
                    text: '\\(p_f\\)'
                }
            },
            yAxis: {
                title: {
                    useHTML: true,
                    text: '\\(s(p_f)\\)'
                }
            },
            tooltip: {
                crosshairs: true
            },
            series: [{
                name: 'Entropy',
                data: data
            }]
        });
    </script>

    <p>As we can see, the maximum is at \(s((0.5, 0.5)) = 1\) and the minimum at \(s((1, 0)) = s(0, 1) = 0\), i.e. completely equally distributed vs. groups which consist only of one type. Values in-between these two extrema change continuously. This makes it a perfect tool for our error term \(E_f(A)\) which we can now define as</p>

    \begin{equation*}
        E_f(A) = \operatorname{mean}(1 - S(A)) + \operatorname{std}(1 - S(A)).
    \end{equation*}

    <p>\(S(A)\) denotes the matrix with the entropy values \(s\) per group and day. Note that the entropies \(S\) are inverted so that we get a low value for a good distribution. The summands have a similar meaning as before.</p>

    <p>To calculate the error \(E_f(A)\) for our example allocation (Equation \eqref{eq:ExampleAllocation}), we need information about the foreigner state for each user. Let's assume that the first three users are foreigners and the last three non-foreigners. In this case, we get the following entropy matrix</p>

    \begin{equation*}
        S(A) \approx
        \begin{pmatrix}
            0 & 0 & 1 \\
            0.92 & 1 & 0 \\
            1 & 0.92 & 0
        \end{pmatrix}
    \end{equation*}

    <p>Let's go through the details for the first group on the second day \((S(A))_{1,0}\). On that day, the first group has three users (second, fourth and sixth). The second user is a foreigner and the other two are non-foreigners, so we get for our probability vector</p>

    \begin{equation*}
        \boldsymbol{p} =
        \begin{pmatrix}
            1/3 \\
            2/3
        \end{pmatrix}.
    \end{equation*}

    <p>The rest is just plugging into the formulas. In the end, we get an error of</p>

    \begin{equation*}
        E_f(A) \approx 0.46 + 0.51 = 0.97.
    \end{equation*}

    <h3>Optimization</h3>
    <p>We now have everything to evaluate whether an allocation \(A\) is good or not; at least according to the error \(E(A)\). But how do we find a good allocation? A naive approach would be to test every combination and take simply the best. However, we have \(\left(n_{\text{days}}!\right)^{n_{\text{users}}}\) combinations to test in total! That is exponential growth over factorial growth here, i.e. intractable in practice for larger values of \(n_{\text{days}}\) or \(n_{\text{users}}\). So, we need a different approach...</p>

    <p>Simply put, the idea is to test different allocations \(A\) randomly and select the one with the lowest error \(E(A)\). We start with a random allocation \(A_0\) and then select one user (also randomly) and try to change her or his assignment over the days. This results in a temporary allocation \(A_{\operatorname{tmp}}\) and when the error decreases, i.e. \(E(A_{\operatorname{tmp}}) &lt; E(A_0)\), we keep the allocation (\(A_1 = A_{\operatorname{tmp}}\)). If the error increases, \(A_{\operatorname{tmp}}\) is discarded. After permuting every assignment of the current user, we randomly select another user and repeat the process. We keep on with this procedure for a certain amount of time and hopefully get a good allocation \(A_*\) at the end.</p>
</body>
</html>
